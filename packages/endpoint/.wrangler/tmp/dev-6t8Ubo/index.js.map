{
  "version": 3,
  "sources": ["../bundle-x3oEA1/checked-fetch.js", "../bundle-x3oEA1/strip-cf-connecting-ip-header.js", "../../../src/auth.ts", "../../../src/cors.ts", "../../../../lib/src/guards.ts", "../../../../lib/src/errors.ts", "../../../../lib/src/client.ts", "../../../../lib/src/utils/markup.ts", "../../../../lib/src/utils/audio.ts", "../../../../lib/src/helpers/definitions.ts", "../../../../lib/src/helpers/thesaurus.ts", "../../../src/cache.ts", "../../../src/handlers/shared.ts", "../../../src/handlers/define.ts", "../../../src/handlers/synonyms.ts", "../../../src/handlers/admin.ts", "../../../src/worker.ts", "../../../src/rate-limiter.ts", "../../../src/index.ts", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-x3oEA1/middleware-insertion-facade.js", "../../../../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/common.ts", "../bundle-x3oEA1/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/cogell/projects/empire/merriam-webster/packages/endpoint/.wrangler/tmp/dev-6t8Ubo",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "import type { Env } from \"./types.js\";\n\n/**\n * Authentication result with the type of auth that succeeded.\n */\nexport type AuthResult =\n  | { valid: true; type: \"user\" | \"admin\" }\n  | { valid: false };\n\n/**\n * Extract Bearer token from Authorization header.\n */\nfunction extractBearerToken(request: Request): string | null {\n  const auth = request.headers.get(\"Authorization\");\n  if (!auth?.startsWith(\"Bearer \")) return null;\n  return auth.slice(7);\n}\n\n/**\n * Validate request has valid user API key.\n *\n * @example\n * if (!validateUserAuth(request, env)) {\n *   return unauthorizedResponse();\n * }\n */\nexport function validateUserAuth(request: Request, env: Env): boolean {\n  const token = extractBearerToken(request);\n  return token === env.WORKER_API_KEY;\n}\n\n/**\n * Validate request has valid admin API key.\n *\n * Admin key is required for destructive operations like cache invalidation.\n */\nexport function validateAdminAuth(request: Request, env: Env): boolean {\n  const token = extractBearerToken(request);\n  return token === env.ADMIN_API_KEY;\n}\n\n/**\n * Validate request has either user or admin auth.\n * Returns which type of auth succeeded.\n *\n * Useful when an endpoint allows both but wants to know which.\n */\nexport function validateAuth(request: Request, env: Env): AuthResult {\n  const token = extractBearerToken(request);\n\n  if (token === env.ADMIN_API_KEY) {\n    return { valid: true, type: \"admin\" };\n  }\n\n  if (token === env.WORKER_API_KEY) {\n    return { valid: true, type: \"user\" };\n  }\n\n  return { valid: false };\n}\n", "import type { Env } from \"./types.js\";\n\n/**\n * Standard CORS headers for API responses.\n */\nexport function corsHeaders(\n  env: Env,\n  origin?: string | null\n): HeadersInit {\n  const allowedOrigins = env.ALLOWED_ORIGINS || \"*\";\n\n  // If specific origins configured, validate the request origin\n  let allowOrigin = \"*\";\n  if (allowedOrigins !== \"*\" && origin) {\n    const origins = allowedOrigins.split(\",\").map((o) => o.trim());\n    if (origins.includes(origin)) {\n      allowOrigin = origin;\n    } else {\n      // Origin not in allowed list - still set header but to first allowed\n      // This will cause browser to reject the response\n      allowOrigin = origins[0];\n    }\n  }\n\n  return {\n    \"Access-Control-Allow-Origin\": allowOrigin,\n    \"Access-Control-Allow-Methods\": \"GET, DELETE, OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n    \"Access-Control-Max-Age\": \"86400\", // Cache preflight for 24 hours\n  };\n}\n\n/**\n * Handle CORS preflight (OPTIONS) request.\n *\n * Browsers send this before actual requests with custom headers.\n */\nexport function handlePreflight(request: Request, env: Env): Response {\n  const origin = request.headers.get(\"Origin\");\n\n  return new Response(null, {\n    status: 204,\n    headers: corsHeaders(env, origin),\n  });\n}\n\n/**\n * Add CORS headers to an existing response.\n *\n * Use this to wrap handler responses.\n */\nexport function withCors(\n  response: Response,\n  env: Env,\n  origin?: string | null\n): Response {\n  const newHeaders = new Headers(response.headers);\n\n  for (const [key, value] of Object.entries(corsHeaders(env, origin))) {\n    newHeaders.set(key, value);\n  }\n\n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers: newHeaders,\n  });\n}\n", "/**\n * Type guards for discriminating MW API responses.\n *\n * These guards enable TypeScript to narrow union types,\n * letting users check if a response contains entries or suggestions.\n */\n\nimport type { DictionaryEntry, DictionaryResponse } from './types/dictionary.js';\nimport type { ThesaurusEntry, ThesaurusResponse } from './types/thesaurus.js';\n\n/**\n * Check if a dictionary response contains entries (word was found).\n *\n * Note: If using the MerriamWebster client, you don't need this guard -\n * just check `result.found`. This guard is for raw API responses.\n *\n * @param response - Raw dictionary API response\n * @returns True if response contains DictionaryEntry objects\n *\n * @example\n * ```ts\n * // For raw API responses (not using the client):\n * const response = await fetch('...').then(r => r.json());\n * if (isDictionaryEntries(response)) {\n *   // TypeScript knows response is DictionaryEntry[]\n *   console.log(response[0].shortdef);\n * }\n * ```\n */\nexport function isDictionaryEntries(\n  response: DictionaryResponse\n): response is DictionaryEntry[] {\n  if (!Array.isArray(response) || response.length === 0) {\n    return false;\n  }\n  // Dictionary entries have a 'meta' object with 'id' and 'uuid'\n  return typeof response[0] === 'object' && response[0] !== null && 'meta' in response[0];\n}\n\n/**\n * Check if a thesaurus response contains entries (word was found).\n *\n * Note: If using the MerriamWebster client, you don't need this guard -\n * just check `result.found`. This guard is for raw API responses.\n *\n * @param response - Raw thesaurus API response\n * @returns True if response contains ThesaurusEntry objects\n *\n * @example\n * ```ts\n * // For raw API responses (not using the client):\n * const response = await fetch('...').then(r => r.json());\n * if (isThesaurusEntries(response)) {\n *   // TypeScript knows response is ThesaurusEntry[]\n *   console.log(response[0].meta.syns);\n * }\n * ```\n */\nexport function isThesaurusEntries(\n  response: ThesaurusResponse\n): response is ThesaurusEntry[] {\n  if (!Array.isArray(response) || response.length === 0) {\n    return false;\n  }\n  // Thesaurus entries have a 'meta' object with 'id' and 'uuid'\n  return typeof response[0] === 'object' && response[0] !== null && 'meta' in response[0];\n}\n\n/**\n * Check if a response contains string suggestions (word not found).\n *\n * This works for both dictionary and thesaurus responses.\n * Returns true for empty arrays as well, since no entries means\n * no word was found.\n *\n * Note: If using the MerriamWebster client, you don't need this guard -\n * just check `result.found`. This guard is for raw API responses.\n *\n * @param response - Raw API response\n * @returns True if response contains string suggestions or is empty\n *\n * @example\n * ```ts\n * // For raw API responses (not using the client):\n * const response = await fetch('...').then(r => r.json());\n * if (isSuggestions(response)) {\n *   // TypeScript knows response is string[]\n *   console.log('Did you mean:', response.join(', '));\n * }\n * ```\n */\nexport function isSuggestions(\n  response: DictionaryResponse | ThesaurusResponse\n): response is string[] {\n  if (!Array.isArray(response)) {\n    return false;\n  }\n  // Empty array = no matches found (treat as suggestions case)\n  if (response.length === 0) {\n    return true;\n  }\n  // Suggestions are plain strings\n  return typeof response[0] === 'string';\n}\n", "/**\n * Custom error classes for MW API errors.\n */\n\n/**\n * Base error class for MW API errors.\n */\nexport class MerriamWebsterError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'MerriamWebsterError';\n  }\n}\n\n/**\n * Error thrown when an API request times out.\n */\nexport class TimeoutError extends MerriamWebsterError {\n  readonly timeout: number;\n\n  constructor(timeout: number) {\n    super(`Request timed out after ${timeout}ms`);\n    this.name = 'TimeoutError';\n    this.timeout = timeout;\n  }\n}\n\n/**\n * Error thrown when there's a network failure.\n */\nexport class NetworkError extends MerriamWebsterError {\n  readonly cause?: Error;\n\n  constructor(message: string, cause?: Error) {\n    super(message);\n    this.name = 'NetworkError';\n    this.cause = cause;\n  }\n}\n\n/**\n * Error thrown when the API key is invalid or missing.\n */\nexport class InvalidKeyError extends MerriamWebsterError {\n  constructor(endpoint: 'dictionary' | 'thesaurus') {\n    super(\n      `Invalid or missing API key for ${endpoint}. ` +\n        'Get your free API key at https://dictionaryapi.com/register/index'\n    );\n    this.name = 'InvalidKeyError';\n  }\n}\n\n/**\n * Error thrown when the API returns an unexpected response format.\n */\nexport class APIError extends MerriamWebsterError {\n  readonly status: number;\n  readonly statusText: string;\n\n  constructor(status: number, statusText: string) {\n    super(`API error: HTTP ${status} ${statusText}`);\n    this.name = 'APIError';\n    this.status = status;\n    this.statusText = statusText;\n  }\n}\n", "/**\n * MerriamWebster API client.\n *\n * Main entry point for interacting with MW Dictionary and Thesaurus APIs.\n */\n\nimport type { DictionaryEntry, DictionaryResponse } from './types/dictionary.js';\nimport type { ThesaurusEntry, ThesaurusResponse } from './types/thesaurus.js';\nimport { isDictionaryEntries, isThesaurusEntries } from './guards.js';\nimport {\n  TimeoutError,\n  NetworkError,\n  InvalidKeyError,\n  APIError,\n} from './errors.js';\n\n/** Base URL for MW API endpoints */\nconst API_BASE_URL = 'https://www.dictionaryapi.com/api/v3/references';\n\n/** Default timeout in milliseconds */\nconst DEFAULT_TIMEOUT = 10000;\n\n/**\n * Configuration options for the MerriamWebster client.\n */\nexport interface MerriamWebsterConfig {\n  /** API key for the Collegiate Dictionary */\n  dictionaryKey?: string;\n  /** API key for the Collegiate Thesaurus */\n  thesaurusKey?: string;\n  /** Default timeout for requests in milliseconds (default: 10000) */\n  timeout?: number;\n}\n\n/**\n * Options for individual API requests.\n */\nexport interface RequestOptions {\n  /** Override the default timeout for this request */\n  timeout?: number;\n  /** Custom AbortSignal for request cancellation */\n  signal?: AbortSignal;\n}\n\n/**\n * Result returned when a word is found in the dictionary.\n */\nexport interface DictionaryFoundResult {\n  found: true;\n  entries: DictionaryEntry[];\n}\n\n/**\n * Result returned when a word is not found in the dictionary.\n */\nexport interface DictionaryNotFoundResult {\n  found: false;\n  suggestions: string[];\n}\n\n/**\n * Discriminated union result type for dictionary lookups.\n * Check the `found` property to determine if entries or suggestions are available.\n */\nexport type DictionaryResult = DictionaryFoundResult | DictionaryNotFoundResult;\n\n/**\n * Result returned when a word is found in the thesaurus.\n */\nexport interface ThesaurusFoundResult {\n  found: true;\n  entries: ThesaurusEntry[];\n}\n\n/**\n * Result returned when a word is not found in the thesaurus.\n */\nexport interface ThesaurusNotFoundResult {\n  found: false;\n  suggestions: string[];\n}\n\n/**\n * Discriminated union result type for thesaurus lookups.\n * Check the `found` property to determine if entries or suggestions are available.\n */\nexport type ThesaurusResult = ThesaurusFoundResult | ThesaurusNotFoundResult;\n\n/**\n * Merriam-Webster API client.\n *\n * Provides typed access to the Collegiate Dictionary and Thesaurus APIs.\n *\n * @example\n * ```ts\n * const mw = new MerriamWebster({\n *   dictionaryKey: 'your-dictionary-key',\n *   thesaurusKey: 'your-thesaurus-key',\n * });\n *\n * // Look up a word definition\n * const result = await mw.define('test');\n * if (result.found) {\n *   console.log(result.entries[0].shortdef);\n * } else {\n *   console.log('Did you mean:', result.suggestions.join(', '));\n * }\n *\n * // Look up synonyms\n * const synonyms = await mw.synonyms('happy');\n * ```\n */\nexport class MerriamWebster {\n  private readonly dictionaryKey?: string;\n  private readonly thesaurusKey?: string;\n  private readonly defaultTimeout: number;\n\n  /**\n   * Create a new MerriamWebster client.\n   *\n   * @param config - Client configuration\n   * @throws Error if neither dictionaryKey nor thesaurusKey is provided\n   */\n  constructor(config: MerriamWebsterConfig) {\n    if (!config.dictionaryKey && !config.thesaurusKey) {\n      throw new Error(\n        'MerriamWebster: At least one of dictionaryKey or thesaurusKey is required'\n      );\n    }\n\n    this.dictionaryKey = config.dictionaryKey;\n    this.thesaurusKey = config.thesaurusKey;\n    this.defaultTimeout = config.timeout ?? DEFAULT_TIMEOUT;\n  }\n\n  /**\n   * Look up a word in the dictionary.\n   *\n   * @param word - The word to look up\n   * @param options - Request options (timeout, signal)\n   * @returns Result with entries if found, or suggestions if not found\n   * @throws Error if dictionaryKey was not configured\n   * @throws TimeoutError if request times out\n   * @throws NetworkError if network request fails\n   * @throws InvalidKeyError if API key is invalid\n   * @throws APIError for other HTTP errors\n   *\n   * @example\n   * ```ts\n   * const result = await mw.define('test');\n   * if (result.found) {\n   *   console.log(result.entries[0].shortdef);\n   * } else {\n   *   console.log('Did you mean:', result.suggestions.join(', '));\n   * }\n   * ```\n   */\n  async define(word: string, options?: RequestOptions): Promise<DictionaryResult> {\n    if (!this.dictionaryKey) {\n      throw new Error('MerriamWebster: dictionaryKey is required for define()');\n    }\n\n    const response = await this.request<DictionaryResponse>(\n      'collegiate',\n      word,\n      this.dictionaryKey,\n      options\n    );\n\n    if (isDictionaryEntries(response)) {\n      return { found: true, entries: response };\n    }\n\n    // Word not found - response is string[] suggestions (possibly empty)\n    return { found: false, suggestions: response };\n  }\n\n  /**\n   * Look up synonyms for a word in the thesaurus.\n   *\n   * @param word - The word to look up\n   * @param options - Request options (timeout, signal)\n   * @returns Result with entries if found, or suggestions if not found\n   * @throws Error if thesaurusKey was not configured\n   * @throws TimeoutError if request times out\n   * @throws NetworkError if network request fails\n   * @throws InvalidKeyError if API key is invalid\n   * @throws APIError for other HTTP errors\n   *\n   * @example\n   * ```ts\n   * const result = await mw.synonyms('happy');\n   * if (result.found) {\n   *   console.log(result.entries[0].meta.syns);\n   * }\n   * ```\n   */\n  async synonyms(word: string, options?: RequestOptions): Promise<ThesaurusResult> {\n    if (!this.thesaurusKey) {\n      throw new Error('MerriamWebster: thesaurusKey is required for synonyms()');\n    }\n\n    const response = await this.request<ThesaurusResponse>(\n      'thesaurus',\n      word,\n      this.thesaurusKey,\n      options\n    );\n\n    if (isThesaurusEntries(response)) {\n      return { found: true, entries: response };\n    }\n\n    // Word not found - response is string[] suggestions (possibly empty)\n    return { found: false, suggestions: response };\n  }\n\n  /**\n   * Make an API request with timeout handling.\n   *\n   * @param endpoint - API endpoint ('collegiate' or 'thesaurus')\n   * @param word - Word to look up\n   * @param apiKey - API key for authentication\n   * @param options - Request options\n   * @returns Parsed JSON response\n   * @throws TimeoutError if request times out\n   * @throws NetworkError if network request fails\n   * @throws InvalidKeyError if API key is invalid (403)\n   * @throws APIError for other HTTP errors\n   */\n  private async request<T>(\n    endpoint: 'collegiate' | 'thesaurus',\n    word: string,\n    apiKey: string,\n    options?: RequestOptions\n  ): Promise<T> {\n    const timeout = options?.timeout ?? this.defaultTimeout;\n    const encodedWord = encodeURIComponent(word);\n    const url = `${API_BASE_URL}/${endpoint}/json/${encodedWord}?key=${apiKey}`;\n\n    // Create AbortController for timeout\n    const controller = new AbortController();\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n    // Set up timeout unless a custom signal was provided\n    if (!options?.signal) {\n      timeoutId = setTimeout(() => controller.abort(), timeout);\n    }\n\n    // Use custom signal or our timeout controller\n    const signal = options?.signal ?? controller.signal;\n\n    try {\n      const response = await fetch(url, { signal });\n\n      // Handle specific HTTP error codes\n      if (response.status === 403) {\n        throw new InvalidKeyError(endpoint === 'collegiate' ? 'dictionary' : 'thesaurus');\n      }\n\n      if (!response.ok) {\n        throw new APIError(response.status, response.statusText);\n      }\n\n      const data = await response.json();\n      return data as T;\n    } catch (error) {\n      // Re-throw our custom errors as-is\n      if (\n        error instanceof TimeoutError ||\n        error instanceof NetworkError ||\n        error instanceof InvalidKeyError ||\n        error instanceof APIError\n      ) {\n        throw error;\n      }\n\n      // Handle timeout abort\n      if (error instanceof Error && error.name === 'AbortError') {\n        if (!options?.signal) {\n          throw new TimeoutError(timeout);\n        }\n        // User-provided signal was aborted\n        throw error;\n      }\n\n      // Wrap other errors as NetworkError\n      if (error instanceof Error) {\n        throw new NetworkError(error.message, error);\n      }\n\n      throw new NetworkError('Unknown network error');\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n}\n", "/**\n * String parsing utilities for MW's custom markup format.\n */\n\n/**\n * Options for parseMarkup function.\n */\nexport interface ParseMarkupOptions {\n  /** Output format: 'text' strips formatting, 'html' converts to HTML tags */\n  format?: 'text' | 'html';\n}\n\n/**\n * Parse MW's custom markup to plain text or HTML.\n *\n * MW uses custom markup in definition text:\n * - {bc} → bold colon (\": \")\n * - {it}...{/it} → italics\n * - {wi}...{/wi} → word illustration (headword in examples)\n * - {sx|word||} → synonym cross-reference\n * - {a_link|word} → auto-link to related word\n * - {d_link|word|sense} → definition link\n * - etc.\n *\n * @param text - Text containing MW markup\n * @param options - Output format options\n * @returns Cleaned text with markup converted or stripped\n *\n * @example\n * ```ts\n * parseMarkup(\"{bc}a means of {a_link|testing}\")\n * // => \": a means of testing\"\n *\n * parseMarkup(\"{it}word{/it}\", { format: 'html' })\n * // => \"<i>word</i>\"\n * ```\n */\nexport function parseMarkup(\n  text: string,\n  options?: ParseMarkupOptions\n): string {\n  const format = options?.format ?? 'text';\n\n  let result = text;\n\n  // Bold colon - definition separator\n  result = result.replace(/\\{bc\\}/g, format === 'html' ? '<b>:</b> ' : ': ');\n\n  // Italic text\n  result = result.replace(\n    /\\{it\\}(.*?)\\{\\/it\\}/g,\n    format === 'html' ? '<i>$1</i>' : '$1'\n  );\n\n  // Word illustration (headword in examples)\n  result = result.replace(\n    /\\{wi\\}(.*?)\\{\\/wi\\}/g,\n    format === 'html' ? '<i>$1</i>' : '$1'\n  );\n\n  // Quote word (headword in quotes)\n  result = result.replace(\n    /\\{qword\\}(.*?)\\{\\/qword\\}/g,\n    format === 'html' ? '<b>$1</b>' : '$1'\n  );\n\n  // Cross-references - extract just the word\n  result = result.replace(/\\{sx\\|([^|]+)\\|[^}]*\\}/g, '$1');\n  result = result.replace(/\\{a_link\\|([^}]+)\\}/g, '$1');\n  result = result.replace(/\\{d_link\\|([^|]+)\\|[^}]*\\}/g, '$1');\n  result = result.replace(/\\{dxt\\|([^|]+)\\|[^}]*\\}/g, '$1');\n\n  // Etymology cross-reference\n  result = result.replace(/\\{dx_ety\\}(.*?)\\{\\/dx_ety\\}/g, '$1');\n\n  // Small caps\n  result = result.replace(\n    /\\{sc\\}(.*?)\\{\\/sc\\}/g,\n    format === 'html' ? '<span style=\"font-variant:small-caps\">$1</span>' : '$1'\n  );\n\n  // Subscript\n  result = result.replace(\n    /\\{inf\\}(.*?)\\{\\/inf\\}/g,\n    format === 'html' ? '<sub>$1</sub>' : '$1'\n  );\n\n  // Superscript\n  result = result.replace(\n    /\\{sup\\}(.*?)\\{\\/sup\\}/g,\n    format === 'html' ? '<sup>$1</sup>' : '$1'\n  );\n\n  // Bold\n  result = result.replace(\n    /\\{b\\}(.*?)\\{\\/b\\}/g,\n    format === 'html' ? '<b>$1</b>' : '$1'\n  );\n\n  // Curly quotes (left/right double quotes)\n  result = result.replace(/\\{ldquo\\}/g, '\"');\n  result = result.replace(/\\{rdquo\\}/g, '\"');\n\n  // Remove any remaining unknown tags\n  result = result.replace(/\\{[^}]+\\}/g, '');\n\n  return result.trim();\n}\n\n/**\n * Remove syllable break markers from a headword.\n *\n * MW uses asterisks to indicate syllable breaks in headwords.\n *\n * @param hw - Headword with syllable markers\n * @returns Clean headword without markers\n *\n * @example\n * ```ts\n * parseHeadword(\"vol*u*mi*nous\")\n * // => \"voluminous\"\n *\n * parseHeadword(\"test\")\n * // => \"test\"\n * ```\n */\nexport function parseHeadword(hw: string): string {\n  return hw.replace(/\\*/g, '');\n}\n", "/**\n * Audio URL builder for MW pronunciation files.\n */\n\nimport type { SoundData } from '../types/common.js';\n\n/** Base URL for MW audio files */\nconst AUDIO_BASE_URL = 'https://media.merriam-webster.com/audio/prons/en/us/mp3';\n\n/**\n * Determine the subdirectory for an audio file based on MW's rules.\n *\n * MW audio files are organized into subdirectories:\n * - \"bix\" prefix → /bix/\n * - \"gg\" prefix → /gg/\n * - Number or punctuation prefix → /number/\n * - Otherwise → first letter of filename\n *\n * @param filename - Audio filename (without extension)\n * @returns Subdirectory name\n */\nfunction getAudioSubdirectory(filename: string): string {\n  if (filename.startsWith('bix')) {\n    return 'bix';\n  }\n  if (filename.startsWith('gg')) {\n    return 'gg';\n  }\n  // Check for number or non-letter start\n  if (/^[^a-zA-Z]/.test(filename)) {\n    return 'number';\n  }\n  // Default to first letter\n  return filename[0]?.toLowerCase() ?? 'a';\n}\n\n/**\n * Build a complete audio URL from pronunciation sound data.\n *\n * @param sound - Sound data from pronunciation entry\n * @returns Complete URL to the MP3 audio file\n *\n * @example\n * ```ts\n * const url = buildAudioUrl({ audio: \"happy001\", ref: \"c\", stat: \"1\" });\n * // => \"https://media.merriam-webster.com/audio/prons/en/us/mp3/h/happy001.mp3\"\n *\n * const url = buildAudioUrl({ audio: \"bixtest01\", ref: \"c\", stat: \"1\" });\n * // => \"https://media.merriam-webster.com/audio/prons/en/us/mp3/bix/bixtest01.mp3\"\n * ```\n */\nexport function buildAudioUrl(sound: SoundData): string {\n  const subdir = getAudioSubdirectory(sound.audio);\n  return `${AUDIO_BASE_URL}/${subdir}/${sound.audio}.mp3`;\n}\n", "/**\n * Helper functions for extracting definitions from MW dictionary entries.\n */\n\nimport type { DictionaryEntry } from '../types/dictionary.js';\nimport type {\n  Definition,\n  Sense,\n  SenseItem,\n  ParallelSenseItem,\n  BindingSubstitute,\n  DefiningText,\n} from '../types/sseq.js';\nimport { parseMarkup } from '../utils/markup.js';\n\n/**\n * Options for flattenDefinitions.\n */\nexport interface FlattenDefinitionsOptions {\n  /** If true, keep MW markup in definitions. Default: false (strip markup) */\n  preserveMarkup?: boolean;\n  /** If true, include definitions from sdsense (subdivided senses). Default: true */\n  includeSdsense?: boolean;\n}\n\n/**\n * Extract plain text definitions from a dictionary entry.\n *\n * MW's `sseq` (sense sequence) structure is deeply nested and complex.\n * This helper flattens it into simple strings, making definitions\n * easy to display without understanding MW's internal format.\n *\n * @param entry - A dictionary entry from the API\n * @param options - Extraction options\n * @returns Array of definition strings\n *\n * @example\n * ```ts\n * const entry = response[0];\n * const definitions = flattenDefinitions(entry);\n * // => [\"a procedure for critical evaluation\", \"a means of testing\", ...]\n *\n * // Keep markup for custom rendering\n * const withMarkup = flattenDefinitions(entry, { preserveMarkup: true });\n * // => [\"{bc}a procedure for critical evaluation\", ...]\n * ```\n */\nexport function flattenDefinitions(\n  entry: DictionaryEntry,\n  options?: FlattenDefinitionsOptions\n): string[] {\n  const definitions: string[] = [];\n  const preserveMarkup = options?.preserveMarkup ?? false;\n  const includeSdsense = options?.includeSdsense ?? true;\n\n  if (!entry.def) {\n    return definitions;\n  }\n\n  for (const def of entry.def) {\n    extractFromDefinition(def, definitions, preserveMarkup, includeSdsense);\n  }\n\n  return definitions;\n}\n\n/**\n * Extract definitions from a Definition object.\n */\nfunction extractFromDefinition(\n  def: Definition,\n  definitions: string[],\n  preserveMarkup: boolean,\n  includeSdsense: boolean\n): void {\n  for (const senseGroup of def.sseq) {\n    for (const senseItem of senseGroup) {\n      extractFromSenseItem(senseItem, definitions, preserveMarkup, includeSdsense);\n    }\n  }\n}\n\n/**\n * Extract definitions from a SenseItem.\n */\nfunction extractFromSenseItem(\n  item: SenseItem,\n  definitions: string[],\n  preserveMarkup: boolean,\n  includeSdsense: boolean\n): void {\n  const [type, data] = item;\n\n  switch (type) {\n    case 'sense':\n      extractFromSense(data as Sense, definitions, preserveMarkup, includeSdsense);\n      break;\n\n    case 'bs':\n      // Binding substitute wraps a sense\n      extractFromSense(\n        (data as BindingSubstitute).sense,\n        definitions,\n        preserveMarkup,\n        includeSdsense\n      );\n      break;\n\n    case 'pseq':\n      // Parallel sequence contains sense or bs items\n      for (const subItem of data as ParallelSenseItem[]) {\n        extractFromSenseItem(subItem, definitions, preserveMarkup, includeSdsense);\n      }\n      break;\n\n    case 'sen':\n      // Truncated sense - no definition text, skip\n      break;\n  }\n}\n\n/**\n * Extract definition text from a Sense object.\n */\nfunction extractFromSense(\n  sense: Sense,\n  definitions: string[],\n  preserveMarkup: boolean,\n  includeSdsense: boolean\n): void {\n  if (sense.dt) {\n    const text = extractTextFromDt(sense.dt, preserveMarkup);\n    if (text) {\n      definitions.push(text);\n    }\n  }\n\n  // Handle subdivided senses (e.g., \"specifically\", \"broadly\")\n  if (includeSdsense && sense.sdsense?.dt) {\n    const text = extractTextFromDt(sense.sdsense.dt, preserveMarkup);\n    if (text) {\n      definitions.push(text);\n    }\n  }\n}\n\n/**\n * Extract text content from DefiningText array.\n */\nfunction extractTextFromDt(dt: DefiningText[], preserveMarkup: boolean): string {\n  const textParts: string[] = [];\n\n  for (const item of dt) {\n    const [type, content] = item;\n\n    if (type === 'text' && typeof content === 'string') {\n      let text = content;\n\n      if (!preserveMarkup) {\n        text = parseMarkup(text);\n      }\n\n      // Remove leading colon and whitespace that often starts definitions\n      text = text.replace(/^:\\s*/, '');\n\n      if (text) {\n        textParts.push(text);\n      }\n    }\n  }\n\n  return textParts.join(' ').trim();\n}\n", "/**\n * Helper functions for extracting data from MW thesaurus entries.\n */\n\nimport type {\n  ThesaurusEntry,\n  ThesaurusSense,\n  ThesaurusWord,\n} from '../types/thesaurus.js';\n\n/**\n * All word lists from a thesaurus sense.\n */\nexport interface WordLists {\n  /** Synonym words */\n  synonyms: string[];\n  /** Related words */\n  related: string[];\n  /** Near antonyms */\n  nearAntonyms: string[];\n  /** Antonyms */\n  antonyms: string[];\n  /** Phrase alternatives */\n  phrases: string[];\n}\n\n/**\n * Extract all word lists from a specific sense of a thesaurus entry.\n *\n * @param entry - A thesaurus entry from the API\n * @param senseNumber - The sense number to find (e.g., \"1\", \"2\")\n * @returns All word types for that sense, or empty arrays if not found\n *\n * @example\n * ```ts\n * const entry = response[0];\n * const lists = getWordListsForSense(entry, \"1\");\n * console.log('Synonyms:', lists.synonyms);\n * console.log('Antonyms:', lists.antonyms);\n * ```\n */\nexport function getWordListsForSense(\n  entry: ThesaurusEntry,\n  senseNumber: string\n): WordLists {\n  const emptyResult: WordLists = {\n    synonyms: [],\n    related: [],\n    nearAntonyms: [],\n    antonyms: [],\n    phrases: [],\n  };\n\n  const sense = findSenseByNumber(entry, senseNumber);\n  if (!sense) {\n    return emptyResult;\n  }\n\n  return {\n    synonyms: flattenWordList(sense.syn_list),\n    related: flattenWordList(sense.rel_list),\n    nearAntonyms: flattenWordList(sense.near_list),\n    antonyms: flattenWordList(sense.ant_list),\n    phrases: flattenWordList(sense.phrase_list),\n  };\n}\n\n/**\n * Extract synonyms for a specific sense of a thesaurus entry.\n *\n * This is a convenience wrapper around getWordListsForSense\n * for when you only need synonyms.\n *\n * @param entry - A thesaurus entry from the API\n * @param senseNumber - The sense number to find (e.g., \"1\", \"2\")\n * @returns Array of synonym words, or empty array if sense not found\n *\n * @example\n * ```ts\n * const entry = response[0];\n * const synonyms = getSynonymsForSense(entry, \"1\");\n * // => [\"joyful\", \"cheerful\", \"glad\", ...]\n * ```\n */\nexport function getSynonymsForSense(\n  entry: ThesaurusEntry,\n  senseNumber: string\n): string[] {\n  return getWordListsForSense(entry, senseNumber).synonyms;\n}\n\n/**\n * Extract antonyms for a specific sense of a thesaurus entry.\n *\n * @param entry - A thesaurus entry from the API\n * @param senseNumber - The sense number to find (e.g., \"1\", \"2\")\n * @returns Array of antonym words, or empty array if sense not found\n *\n * @example\n * ```ts\n * const entry = response[0];\n * const antonyms = getAntonymsForSense(entry, \"1\");\n * // => [\"sad\", \"unhappy\", \"miserable\", ...]\n * ```\n */\nexport function getAntonymsForSense(\n  entry: ThesaurusEntry,\n  senseNumber: string\n): string[] {\n  return getWordListsForSense(entry, senseNumber).antonyms;\n}\n\n/**\n * Find a sense by its sense number within an entry.\n */\nfunction findSenseByNumber(\n  entry: ThesaurusEntry,\n  senseNumber: string\n): ThesaurusSense | null {\n  for (const def of entry.def) {\n    for (const senseGroup of def.sseq) {\n      for (const [type, sense] of senseGroup) {\n        if (type === 'sense' && sense.sn === senseNumber) {\n          return sense;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Flatten a nested word list into plain strings.\n *\n * MW groups words in nested arrays. This extracts\n * just the word strings (wd property).\n */\nfunction flattenWordList(list?: ThesaurusWord[][]): string[] {\n  if (!list) {\n    return [];\n  }\n\n  const words: string[] = [];\n  for (const group of list) {\n    for (const word of group) {\n      words.push(word.wd);\n    }\n  }\n  return words;\n}\n", "import type { CachedResponse } from \"./types.js\";\n\n/** TTL for not-found responses (24 hours in seconds) */\nconst NOT_FOUND_TTL = 60 * 60 * 24;\n\n/**\n * Generate cache key from type and word.\n *\n * Uses pipe separator which is safe (not in dictionary words).\n * Lowercase for case-insensitive matching.\n */\nexport function getCacheKey(\n  type: \"define\" | \"synonyms\",\n  word: string\n): string {\n  return `${type}|${word.toLowerCase()}`;\n}\n\n/**\n * Get cached response from KV.\n *\n * Returns null if not cached or expired.\n */\nexport async function getCached(\n  kv: KVNamespace,\n  type: \"define\" | \"synonyms\",\n  word: string\n): Promise<CachedResponse | null> {\n  const key = getCacheKey(type, word);\n  return kv.get(key, \"json\");\n}\n\n/**\n * Cache a response in KV.\n *\n * - Found responses: cached forever (no TTL)\n * - Not-found responses: cached for 24 hours\n *\n * The TTL difference allows MW to add new words while still\n * preventing repeated lookups for typos.\n */\nexport async function setCache(\n  kv: KVNamespace,\n  type: \"define\" | \"synonyms\",\n  word: string,\n  data: unknown,\n  found: boolean\n): Promise<void> {\n  const key = getCacheKey(type, word);\n  const value: CachedResponse = {\n    data,\n    cachedAt: new Date().toISOString(),\n    found,\n  };\n\n  // Found responses: cache forever. Not-found: 24h TTL\n  const options = found ? {} : { expirationTtl: NOT_FOUND_TTL };\n  await kv.put(key, JSON.stringify(value), options);\n}\n\n/**\n * Delete a cached response from KV.\n *\n * Used by admin endpoint for cache invalidation.\n */\nexport async function deleteCache(\n  kv: KVNamespace,\n  type: \"define\" | \"synonyms\",\n  word: string\n): Promise<void> {\n  const key = getCacheKey(type, word);\n  await kv.delete(key);\n}\n\n/**\n * Check if a word exists in cache (without retrieving full data).\n *\n * Useful for admin/debugging endpoints.\n */\nexport async function hasCache(\n  kv: KVNamespace,\n  type: \"define\" | \"synonyms\",\n  word: string\n): Promise<boolean> {\n  const key = getCacheKey(type, word);\n  const metadata = await kv.getWithMetadata(key);\n  return metadata.value !== null;\n}\n", "import { MerriamWebsterError } from \"@merriam-webster/lib\";\nimport type { Env, RateLimitStatus, APIErrorResponse } from \"../types.js\";\n\nconst RATE_LIMITER_ID = \"global\";\n\n/**\n * Check rate limit and increment counter.\n * Call this for cache misses only.\n */\nexport async function checkRateLimit(env: Env): Promise<RateLimitStatus> {\n  const id = env.RATE_LIMITER.idFromName(RATE_LIMITER_ID);\n  const stub = env.RATE_LIMITER.get(id);\n  const response = await stub.fetch(new Request(\"http://do/check\"));\n  return response.json();\n}\n\n/**\n * Get current rate limit status without incrementing.\n * Safe to call for cache hits.\n */\nexport async function getRateLimitStatus(env: Env): Promise<RateLimitStatus> {\n  const id = env.RATE_LIMITER.idFromName(RATE_LIMITER_ID);\n  const stub = env.RATE_LIMITER.get(id);\n  const response = await stub.fetch(new Request(\"http://do/status\"));\n  return response.json();\n}\n\n/**\n * Build 429 response for rate-limited requests.\n */\nexport function rateLimitedResponse(rateLimit: RateLimitStatus): Response {\n  const retryAfter = Math.ceil(\n    (new Date(rateLimit.resetsAt).getTime() - Date.now()) / 1000\n  );\n\n  return Response.json(\n    {\n      success: false,\n      error: {\n        code: \"RATE_LIMITED\",\n        message: \"Daily API limit exceeded. Try again tomorrow.\",\n      },\n      rateLimit: {\n        remaining: 0,\n        limit: rateLimit.limit,\n        resetsAt: rateLimit.resetsAt,\n      },\n    } satisfies APIErrorResponse,\n    {\n      status: 429,\n      headers: {\n        \"Retry-After\": String(retryAfter),\n        \"X-RateLimit-Limit\": String(rateLimit.limit),\n        \"X-RateLimit-Remaining\": \"0\",\n        \"X-RateLimit-Reset\": rateLimit.resetsAt,\n      },\n    }\n  );\n}\n\n/**\n * Handle errors from MW API calls.\n */\nexport function handleMWError(\n  error: unknown,\n  rateLimit: RateLimitStatus\n): Response {\n  if (error instanceof MerriamWebsterError) {\n    const status = error.name === \"InvalidKeyError\" ? 503 : 502;\n    return Response.json(\n      {\n        success: false,\n        error: {\n          code: \"UPSTREAM_ERROR\",\n          message: \"Dictionary service temporarily unavailable\",\n        },\n        rateLimit: {\n          remaining: rateLimit.remaining,\n          limit: rateLimit.limit,\n          resetsAt: rateLimit.resetsAt,\n        },\n      } satisfies APIErrorResponse,\n      { status }\n    );\n  }\n\n  throw error; // Let outer handler catch unexpected errors\n}\n\n/**\n * Validate word input from URL.\n * Returns error response if invalid, null if valid.\n */\nexport function validateWord(word: string): Response | null {\n  if (!word || word.length > 100) {\n    return Response.json(\n      {\n        success: false,\n        error: {\n          code: \"INVALID_WORD\",\n          message: \"Word must be 1-100 characters\",\n        },\n      } satisfies APIErrorResponse,\n      { status: 400 }\n    );\n  }\n  return null; // Valid\n}\n", "import { MerriamWebster } from \"@merriam-webster/lib\";\nimport type { Env, APISuccessResponse } from \"../types.js\";\nimport { getCached, setCache } from \"../cache.js\";\nimport {\n  checkRateLimit,\n  getRateLimitStatus,\n  rateLimitedResponse,\n  handleMWError,\n  validateWord,\n} from \"./shared.js\";\n\n/**\n * Handle GET /define/:word\n *\n * Flow:\n * 1. Parse word from URL\n * 2. Validate input\n * 3. Check KV cache \u2192 return if hit\n * 4. Check rate limit \u2192 return 429 if exceeded\n * 5. Call MW Dictionary API\n * 6. Cache response (with appropriate TTL)\n * 7. Return response\n */\nexport async function handleDefine(\n  request: Request,\n  env: Env,\n  ctx: ExecutionContext\n): Promise<Response> {\n  const url = new URL(request.url);\n  const word = decodeURIComponent(url.pathname.replace(\"/define/\", \"\"));\n\n  // Validate input\n  const invalid = validateWord(word);\n  if (invalid) return invalid;\n\n  // Check cache first (no rate limit cost)\n  const cached = await getCached(env.CACHE, \"define\", word);\n  if (cached) {\n    const rateLimit = await getRateLimitStatus(env);\n    return Response.json(\n      {\n        success: true,\n        data: cached.data,\n        cached: true,\n        rateLimit: {\n          remaining: rateLimit.remaining,\n          limit: rateLimit.limit,\n          resetsAt: rateLimit.resetsAt,\n        },\n      } satisfies APISuccessResponse<unknown>,\n      {\n        status: 200,\n        headers: { \"X-Cache\": \"HIT\" },\n      }\n    );\n  }\n\n  // Check rate limit (only on cache miss)\n  const rateLimit = await checkRateLimit(env);\n  if (!rateLimit.allowed) {\n    return rateLimitedResponse(rateLimit);\n  }\n\n  // Call MW Dictionary API\n  try {\n    const mw = new MerriamWebster({\n      dictionaryKey: env.MW_DICTIONARY_KEY,\n    });\n\n    const result = await mw.define(word);\n\n    // Cache in background\n    ctx.waitUntil(setCache(env.CACHE, \"define\", word, result, result.found));\n\n    return Response.json(\n      {\n        success: true,\n        data: result,\n        cached: false,\n        rateLimit: {\n          remaining: rateLimit.remaining,\n          limit: rateLimit.limit,\n          resetsAt: rateLimit.resetsAt,\n        },\n      } satisfies APISuccessResponse<typeof result>,\n      {\n        status: 200,\n        headers: { \"X-Cache\": \"MISS\" },\n      }\n    );\n  } catch (error) {\n    return handleMWError(error, rateLimit);\n  }\n}\n", "import { MerriamWebster } from \"@merriam-webster/lib\";\nimport type { Env, APISuccessResponse } from \"../types.js\";\nimport { getCached, setCache } from \"../cache.js\";\nimport {\n  checkRateLimit,\n  getRateLimitStatus,\n  rateLimitedResponse,\n  handleMWError,\n  validateWord,\n} from \"./shared.js\";\n\n/**\n * Handle GET /synonyms/:word\n *\n * Flow mirrors define.ts but uses thesaurus API.\n */\nexport async function handleSynonyms(\n  request: Request,\n  env: Env,\n  ctx: ExecutionContext\n): Promise<Response> {\n  const url = new URL(request.url);\n  const word = decodeURIComponent(url.pathname.replace(\"/synonyms/\", \"\"));\n\n  // Validate input\n  const invalid = validateWord(word);\n  if (invalid) return invalid;\n\n  // Check cache first (no rate limit cost)\n  const cached = await getCached(env.CACHE, \"synonyms\", word);\n  if (cached) {\n    const rateLimit = await getRateLimitStatus(env);\n    return Response.json(\n      {\n        success: true,\n        data: cached.data,\n        cached: true,\n        rateLimit: {\n          remaining: rateLimit.remaining,\n          limit: rateLimit.limit,\n          resetsAt: rateLimit.resetsAt,\n        },\n      } satisfies APISuccessResponse<unknown>,\n      {\n        status: 200,\n        headers: { \"X-Cache\": \"HIT\" },\n      }\n    );\n  }\n\n  // Check rate limit (only on cache miss)\n  const rateLimit = await checkRateLimit(env);\n  if (!rateLimit.allowed) {\n    return rateLimitedResponse(rateLimit);\n  }\n\n  // Call MW Thesaurus API\n  try {\n    const mw = new MerriamWebster({\n      thesaurusKey: env.MW_THESAURUS_KEY,\n    });\n\n    const result = await mw.synonyms(word);\n\n    // Cache in background\n    ctx.waitUntil(setCache(env.CACHE, \"synonyms\", word, result, result.found));\n\n    return Response.json(\n      {\n        success: true,\n        data: result,\n        cached: false,\n        rateLimit: {\n          remaining: rateLimit.remaining,\n          limit: rateLimit.limit,\n          resetsAt: rateLimit.resetsAt,\n        },\n      } satisfies APISuccessResponse<typeof result>,\n      {\n        status: 200,\n        headers: { \"X-Cache\": \"MISS\" },\n      }\n    );\n  } catch (error) {\n    return handleMWError(error, rateLimit);\n  }\n}\n", "import type { Env, APIErrorResponse } from \"../types.js\";\nimport { deleteCache, hasCache, getCacheKey } from \"../cache.js\";\n\n/**\n * Handle DELETE /cache/:type/:word\n *\n * Invalidates a specific cached entry.\n * Requires ADMIN_API_KEY authentication (checked in worker.ts).\n *\n * @example\n * curl -X DELETE \\\n *   -H \"Authorization: Bearer $ADMIN_API_KEY\" \\\n *   https://api.example.com/cache/define/hello\n */\nexport async function handleCacheDelete(\n  request: Request,\n  env: Env\n): Promise<Response> {\n  const url = new URL(request.url);\n  // Path: /cache/:type/:word\n  const match = url.pathname.match(/^\\/cache\\/(define|synonyms)\\/(.+)$/);\n\n  if (!match) {\n    return Response.json(\n      {\n        success: false,\n        error: {\n          code: \"INVALID_PATH\",\n          message: \"Path must be /cache/{define|synonyms}/{word}\",\n        },\n      } satisfies APIErrorResponse,\n      { status: 400 }\n    );\n  }\n\n  const type = match[1] as \"define\" | \"synonyms\";\n  const word = decodeURIComponent(match[2]);\n\n  // Validate word\n  if (!word || word.length > 100) {\n    return Response.json(\n      {\n        success: false,\n        error: {\n          code: \"INVALID_WORD\",\n          message: \"Word must be 1-100 characters\",\n        },\n      } satisfies APIErrorResponse,\n      { status: 400 }\n    );\n  }\n\n  // Check if entry exists\n  const exists = await hasCache(env.CACHE, type, word);\n\n  if (!exists) {\n    return Response.json(\n      {\n        success: false,\n        error: {\n          code: \"NOT_FOUND\",\n          message: `No cached entry for ${type}:${word}`,\n        },\n      } satisfies APIErrorResponse,\n      { status: 404 }\n    );\n  }\n\n  // Delete the entry\n  await deleteCache(env.CACHE, type, word);\n\n  return Response.json(\n    {\n      success: true as const,\n      data: {\n        deleted: true,\n        type,\n        word,\n        key: getCacheKey(type, word),\n      },\n    },\n    { status: 200 }\n  );\n}\n", "import type { Env, APIErrorResponse, RateLimitStatus } from \"./types.js\";\nimport { validateUserAuth, validateAdminAuth } from \"./auth.js\";\nimport { handlePreflight, withCors } from \"./cors.js\";\nimport { handleDefine } from \"./handlers/define.js\";\nimport { handleSynonyms } from \"./handlers/synonyms.js\";\nimport { handleCacheDelete } from \"./handlers/admin.js\";\n\nconst RATE_LIMITER_ID = \"global\";\n\n/**\n * Main request handler for the worker.\n *\n * Flow:\n * 1. CORS preflight \u2192 immediate response\n * 2. Route matching\n * 3. Auth check (per-route requirements)\n * 4. Delegate to handler\n * 5. Return with CORS headers\n */\nexport async function handleRequest(\n  request: Request,\n  env: Env,\n  ctx: ExecutionContext\n): Promise<Response> {\n  const origin = request.headers.get(\"Origin\");\n\n  // Handle CORS preflight\n  if (request.method === \"OPTIONS\") {\n    return handlePreflight(request, env);\n  }\n\n  const url = new URL(request.url);\n  const path = url.pathname;\n\n  try {\n    // Health check (no auth)\n    if (path === \"/health\") {\n      return withCors(handleHealth(), env, origin);\n    }\n\n    // Rate limit status (user auth)\n    if (path === \"/rate-limit/status\") {\n      if (!validateUserAuth(request, env)) {\n        return withCors(unauthorizedResponse(), env, origin);\n      }\n      return withCors(await handleRateLimitStatus(env), env, origin);\n    }\n\n    // Dictionary lookup (user auth)\n    if (path.startsWith(\"/define/\")) {\n      if (!validateUserAuth(request, env)) {\n        return withCors(unauthorizedResponse(), env, origin);\n      }\n      return withCors(await handleDefine(request, env, ctx), env, origin);\n    }\n\n    // Thesaurus lookup (user auth)\n    if (path.startsWith(\"/synonyms/\")) {\n      if (!validateUserAuth(request, env)) {\n        return withCors(unauthorizedResponse(), env, origin);\n      }\n      return withCors(await handleSynonyms(request, env, ctx), env, origin);\n    }\n\n    // Cache invalidation (admin auth)\n    if (path.startsWith(\"/cache/\") && request.method === \"DELETE\") {\n      if (!validateAdminAuth(request, env)) {\n        return withCors(forbiddenResponse(), env, origin);\n      }\n      return withCors(await handleCacheDelete(request, env), env, origin);\n    }\n\n    // Not found\n    return withCors(notFoundResponse(), env, origin);\n  } catch (error) {\n    console.error(\"Unhandled error:\", error);\n    return withCors(internalErrorResponse(), env, origin);\n  }\n}\n\n/**\n * Health check handler.\n */\nfunction handleHealth(): Response {\n  return Response.json({\n    status: \"ok\",\n    timestamp: new Date().toISOString(),\n  });\n}\n\n/**\n * Rate limit status handler.\n */\nasync function handleRateLimitStatus(env: Env): Promise<Response> {\n  const id = env.RATE_LIMITER.idFromName(RATE_LIMITER_ID);\n  const stub = env.RATE_LIMITER.get(id);\n  const response = await stub.fetch(new Request(\"http://do/status\"));\n  const status: RateLimitStatus = await response.json();\n\n  return Response.json({\n    success: true,\n    data: status,\n  });\n}\n\n/**\n * 401 Unauthorized response.\n */\nfunction unauthorizedResponse(): Response {\n  return Response.json(\n    {\n      success: false,\n      error: {\n        code: \"UNAUTHORIZED\",\n        message: \"Invalid or missing API key\",\n      },\n    } satisfies APIErrorResponse,\n    { status: 401 }\n  );\n}\n\n/**\n * 403 Forbidden response.\n */\nfunction forbiddenResponse(): Response {\n  return Response.json(\n    {\n      success: false,\n      error: {\n        code: \"FORBIDDEN\",\n        message: \"Admin access required\",\n      },\n    } satisfies APIErrorResponse,\n    { status: 403 }\n  );\n}\n\n/**\n * 404 Not Found response.\n */\nfunction notFoundResponse(): Response {\n  return Response.json(\n    {\n      success: false,\n      error: {\n        code: \"NOT_FOUND\",\n        message: \"Endpoint not found\",\n      },\n    } satisfies APIErrorResponse,\n    { status: 404 }\n  );\n}\n\n/**\n * 500 Internal Error response.\n */\nfunction internalErrorResponse(): Response {\n  return Response.json(\n    {\n      success: false,\n      error: {\n        code: \"INTERNAL_ERROR\",\n        message: \"An unexpected error occurred\",\n      },\n    } satisfies APIErrorResponse,\n    { status: 500 }\n  );\n}\n", "import type { Env, RateLimitStatus } from \"./types.js\";\n\n/**\n * Rate limiter Durable Object.\n *\n * Maintains a single global counter that resets at midnight UTC each day.\n * Uses Durable Object storage for strong consistency across all edge locations.\n *\n * @example\n * // In worker:\n * const id = env.RATE_LIMITER.idFromName('global');\n * const stub = env.RATE_LIMITER.get(id);\n * const response = await stub.fetch(new Request('http://do/check'));\n * const result: RateLimitStatus = await response.json();\n */\nexport class RateLimiter implements DurableObject {\n  private state: DurableObjectState;\n  private limit: number;\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state;\n    this.limit = parseInt(env.DAILY_REQUEST_LIMIT || \"1000\", 10);\n  }\n\n  /**\n   * Handle incoming requests to the Durable Object.\n   *\n   * Endpoints:\n   * - GET /check - Check rate limit and increment counter (atomic)\n   * - GET /status - Get current status without incrementing\n   */\n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n\n    if (url.pathname === \"/check\") {\n      return this.checkAndIncrement();\n    }\n\n    if (url.pathname === \"/status\") {\n      return this.getStatus();\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n  }\n\n  /**\n   * Check if request is allowed and increment counter atomically.\n   *\n   * If it's a new day (UTC), the counter resets automatically.\n   */\n  private async checkAndIncrement(): Promise<Response> {\n    const today = this.getTodayUTC();\n    const stored = await this.state.storage.get<{\n      date: string;\n      count: number;\n    }>(\"counter\");\n\n    let count = 0;\n    if (stored && stored.date === today) {\n      count = stored.count;\n    }\n    // If stored.date !== today, count stays 0 (new day = reset)\n\n    if (count >= this.limit) {\n      return Response.json({\n        allowed: false,\n        remaining: 0,\n        limit: this.limit,\n        resetsAt: this.getNextMidnightUTC(),\n      } satisfies RateLimitStatus);\n    }\n\n    // Increment and save atomically\n    await this.state.storage.put(\"counter\", {\n      date: today,\n      count: count + 1,\n    });\n\n    return Response.json({\n      allowed: true,\n      remaining: this.limit - count - 1,\n      limit: this.limit,\n      resetsAt: this.getNextMidnightUTC(),\n    } satisfies RateLimitStatus);\n  }\n\n  /**\n   * Get current rate limit status without incrementing.\n   *\n   * Used for /rate-limit/status endpoint.\n   */\n  private async getStatus(): Promise<Response> {\n    const today = this.getTodayUTC();\n    const stored = await this.state.storage.get<{\n      date: string;\n      count: number;\n    }>(\"counter\");\n\n    let count = 0;\n    if (stored && stored.date === today) {\n      count = stored.count;\n    }\n\n    return Response.json({\n      allowed: true, // Status check doesn't consume\n      remaining: this.limit - count,\n      limit: this.limit,\n      resetsAt: this.getNextMidnightUTC(),\n    } satisfies RateLimitStatus);\n  }\n\n  /**\n   * Get today's date in UTC as YYYY-MM-DD.\n   */\n  private getTodayUTC(): string {\n    return new Date().toISOString().split(\"T\")[0];\n  }\n\n  /**\n   * Get ISO timestamp of next midnight UTC.\n   */\n  private getNextMidnightUTC(): string {\n    const tomorrow = new Date();\n    tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);\n    tomorrow.setUTCHours(0, 0, 0, 0);\n    return tomorrow.toISOString();\n  }\n}\n", "/**\n * Merriam-Webster API Cloudflare Worker\n *\n * This worker provides a rate-limited, cached proxy to the MW Dictionary\n * and Thesaurus APIs.\n *\n * Endpoints:\n * - GET /define/:word - Dictionary lookup\n * - GET /synonyms/:word - Thesaurus lookup\n * - GET /health - Health check\n * - GET /rate-limit/status - Current rate limit status\n * - DELETE /cache/:type/:word - Cache invalidation (admin only)\n */\n\nimport { handleRequest } from \"./worker.js\";\nimport { RateLimiter } from \"./rate-limiter.js\";\nimport type { Env } from \"./types.js\";\n\n// Export Durable Object class for wrangler\nexport { RateLimiter };\n\n// Export default fetch handler\nexport default {\n  async fetch(\n    request: Request,\n    env: Env,\n    ctx: ExecutionContext\n  ): Promise<Response> {\n    return handleRequest(request, env, ctx);\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/cogell/projects/empire/merriam-webster/packages/endpoint/src/index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/cogell/projects/empire/merriam-webster/node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/cogell/projects/empire/merriam-webster/node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/cogell/projects/empire/merriam-webster/packages/endpoint/src/index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/cogell/projects/empire/merriam-webster/packages/endpoint/.wrangler/tmp/bundle-x3oEA1/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/cogell/projects/empire/merriam-webster/node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/cogell/projects/empire/merriam-webster/packages/endpoint/.wrangler/tmp/bundle-x3oEA1/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/cogell/projects/empire/merriam-webster/packages/endpoint/.wrangler/tmp/bundle-x3oEA1/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": ";;;;AAAA,IAAM,OAAO,oBAAI,IAAI;AAErB,SAAS,SAAS,SAAS,MAAM;AAChC,QAAM,MACL,mBAAmB,MAChB,UACA,IAAI;AAAA,KACH,OAAO,YAAY,WACjB,IAAI,QAAQ,SAAS,IAAI,IACzB,SACD;AAAA,EACH;AACH,MAAI,IAAI,QAAQ,IAAI,SAAS,SAAS,IAAI,aAAa,UAAU;AAChE,QAAI,CAAC,KAAK,IAAI,IAAI,SAAS,CAAC,GAAG;AAC9B,WAAK,IAAI,IAAI,SAAS,CAAC;AACvB,cAAQ;AAAA,QACP;AAAA,KACO,IAAI,SAAS;AAAA;AAAA,MACrB;AAAA,IACD;AAAA,EACD;AACD;AAnBS;AAqBT,WAAW,QAAQ,IAAI,MAAM,WAAW,OAAO;AAAA,EAC9C,MAAM,QAAQ,SAAS,UAAU;AAChC,UAAM,CAAC,SAAS,IAAI,IAAI;AACxB,aAAS,SAAS,IAAI;AACtB,WAAO,QAAQ,MAAM,QAAQ,SAAS,QAAQ;AAAA,EAC/C;AACD,CAAC;;;AC7BD,SAAS,0BAA0B,OAAO,MAAM;AAC/C,QAAM,UAAU,IAAI,QAAQ,OAAO,IAAI;AACvC,UAAQ,QAAQ,OAAO,kBAAkB;AACzC,SAAO;AACR;AAJS;AAMT,WAAW,QAAQ,IAAI,MAAM,WAAW,OAAO;AAAA,EAC9C,MAAM,QAAQ,SAAS,UAAU;AAChC,WAAO,QAAQ,MAAM,QAAQ,SAAS;AAAA,MACrC,0BAA0B,MAAM,MAAM,QAAQ;AAAA,IAC/C,CAAC;AAAA,EACF;AACD,CAAC;;;ACAD,SAAS,mBAAmB,SAAiC;AAC3D,QAAM,OAAO,QAAQ,QAAQ,IAAI,eAAe;AAChD,MAAI,CAAC,MAAM,WAAW,SAAS;AAAG,WAAO;AACzC,SAAO,KAAK,MAAM,CAAC;AACrB;AAJS;AAcF,SAAS,iBAAiB,SAAkB,KAAmB;AACpE,QAAM,QAAQ,mBAAmB,OAAO;AACxC,SAAO,UAAU,IAAI;AACvB;AAHgB;AAUT,SAAS,kBAAkB,SAAkB,KAAmB;AACrE,QAAM,QAAQ,mBAAmB,OAAO;AACxC,SAAO,UAAU,IAAI;AACvB;AAHgB;;;AC/BT,SAAS,YACd,KACA,QACa;AACb,QAAM,iBAAiB,IAAI,mBAAmB;AAG9C,MAAI,cAAc;AAClB,MAAI,mBAAmB,OAAO,QAAQ;AACpC,UAAM,UAAU,eAAe,MAAM,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,CAAC;AAC7D,QAAI,QAAQ,SAAS,MAAM,GAAG;AAC5B,oBAAc;AAAA,IAChB,OAAO;AAGL,oBAAc,QAAQ,CAAC;AAAA,IACzB;AAAA,EACF;AAEA,SAAO;AAAA,IACL,+BAA+B;AAAA,IAC/B,gCAAgC;AAAA,IAChC,gCAAgC;AAAA,IAChC,0BAA0B;AAAA;AAAA,EAC5B;AACF;AAzBgB;AAgCT,SAAS,gBAAgB,SAAkB,KAAoB;AACpE,QAAM,SAAS,QAAQ,QAAQ,IAAI,QAAQ;AAE3C,SAAO,IAAI,SAAS,MAAM;AAAA,IACxB,QAAQ;AAAA,IACR,SAAS,YAAY,KAAK,MAAM;AAAA,EAClC,CAAC;AACH;AAPgB;AAcT,SAAS,SACd,UACA,KACA,QACU;AACV,QAAM,aAAa,IAAI,QAAQ,SAAS,OAAO;AAE/C,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,YAAY,KAAK,MAAM,CAAC,GAAG;AACnE,eAAW,IAAI,KAAK,KAAK;AAAA,EAC3B;AAEA,SAAO,IAAI,SAAS,SAAS,MAAM;AAAA,IACjC,QAAQ,SAAS;AAAA,IACjB,YAAY,SAAS;AAAA,IACrB,SAAS;AAAA,EACX,CAAC;AACH;AAhBgB;;;ACtBT,SAAS,oBACd,UAC+B;AAC/B,MAAI,CAAC,MAAM,QAAQ,QAAQ,KAAK,SAAS,WAAW,GAAG;AACrD,WAAO;EACT;AAEA,SAAO,OAAO,SAAS,CAAC,MAAM,YAAY,SAAS,CAAC,MAAM,QAAQ,UAAU,SAAS,CAAC;AACxF;AARgB;AA6BT,SAAS,mBACd,UAC8B;AAC9B,MAAI,CAAC,MAAM,QAAQ,QAAQ,KAAK,SAAS,WAAW,GAAG;AACrD,WAAO;EACT;AAEA,SAAO,OAAO,SAAS,CAAC,MAAM,YAAY,SAAS,CAAC,MAAM,QAAQ,UAAU,SAAS,CAAC;AACxF;AARgB;ACnDT,IAAM,sBAAN,qCAAkC,MAAM;EAC7C,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;EACd;AACF,GALO;AAUA,IAAM,eAAN,qCAA2B,oBAAoB;EAGpD,YAAY,SAAiB;AAC3B,UAAM,2BAA2B,WAAW;AAC5C,SAAK,OAAO;AACZ,SAAK,UAAU;EACjB;AACF,GARO;AAaA,IAAM,eAAN,qCAA2B,oBAAoB;EAGpD,YAAY,SAAiB,OAAe;AAC1C,UAAM,OAAO;AACb,SAAK,OAAO;AACZ,SAAK,QAAQ;EACf;AACF,GARO;AAaA,IAAM,kBAAN,qCAA8B,oBAAoB;EACvD,YAAY,UAAsC;AAChD;MACE,kCAAkC;IAAQ;AAG5C,SAAK,OAAO;EACd;AACF,GARO;AAaA,IAAM,WAAN,qCAAuB,oBAAoB;EAIhD,YAAY,QAAgB,YAAoB;AAC9C,UAAM,mBAAmB,UAAU,YAAY;AAC/C,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,aAAa;EACpB;AACF,GAVO;ACvCP,IAAM,eAAe;AAGrB,IAAM,kBAAkB;AA4FjB,IAAM,iBAAN,6BAAqB;;;;;;;EAW1B,YAAY,QAA8B;AACxC,QAAI,CAAC,OAAO,iBAAiB,CAAC,OAAO,cAAc;AACjD,YAAM,IAAI;QACR;MAAA;IAEJ;AAEA,SAAK,gBAAgB,OAAO;AAC5B,SAAK,eAAe,OAAO;AAC3B,SAAK,iBAAiB,OAAO,WAAW;EAC1C;;;;;;;;;;;;;;;;;;;;;;;EAwBA,MAAM,OAAO,MAAc,SAAqD;AAC9E,QAAI,CAAC,KAAK,eAAe;AACvB,YAAM,IAAI,MAAM,wDAAwD;IAC1E;AAEA,UAAM,WAAW,MAAM,KAAK;MAC1B;MACA;MACA,KAAK;MACL;IAAA;AAGF,QAAI,oBAAoB,QAAQ,GAAG;AACjC,aAAO,EAAE,OAAO,MAAM,SAAS,SAAA;IACjC;AAGA,WAAO,EAAE,OAAO,OAAO,aAAa,SAAA;EACtC;;;;;;;;;;;;;;;;;;;;;EAsBA,MAAM,SAAS,MAAc,SAAoD;AAC/E,QAAI,CAAC,KAAK,cAAc;AACtB,YAAM,IAAI,MAAM,yDAAyD;IAC3E;AAEA,UAAM,WAAW,MAAM,KAAK;MAC1B;MACA;MACA,KAAK;MACL;IAAA;AAGF,QAAI,mBAAmB,QAAQ,GAAG;AAChC,aAAO,EAAE,OAAO,MAAM,SAAS,SAAA;IACjC;AAGA,WAAO,EAAE,OAAO,OAAO,aAAa,SAAA;EACtC;;;;;;;;;;;;;;EAeA,MAAc,QACZ,UACA,MACA,QACA,SACY;AACZ,UAAM,UAAU,SAAS,WAAW,KAAK;AACzC,UAAM,cAAc,mBAAmB,IAAI;AAC3C,UAAM,MAAM,GAAG,gBAAgB,iBAAiB,mBAAmB;AAGnE,UAAM,aAAa,IAAI,gBAAA;AACvB,QAAI;AAGJ,QAAI,CAAC,SAAS,QAAQ;AACpB,kBAAY,WAAW,MAAM,WAAW,MAAA,GAAS,OAAO;IAC1D;AAGA,UAAM,SAAS,SAAS,UAAU,WAAW;AAE7C,QAAI;AACF,YAAM,WAAW,MAAM,MAAM,KAAK,EAAE,OAAA,CAAQ;AAG5C,UAAI,SAAS,WAAW,KAAK;AAC3B,cAAM,IAAI,gBAAgB,aAAa,eAAe,eAAe,WAAW;MAClF;AAEA,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,SAAS,SAAS,QAAQ,SAAS,UAAU;MACzD;AAEA,YAAM,OAAO,MAAM,SAAS,KAAA;AAC5B,aAAO;IACT,SAAS,OAAT;AAEE,UACE,iBAAiB,gBACjB,iBAAiB,gBACjB,iBAAiB,mBACjB,iBAAiB,UACjB;AACA,cAAM;MACR;AAGA,UAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,YAAI,CAAC,SAAS,QAAQ;AACpB,gBAAM,IAAI,aAAa,OAAO;QAChC;AAEA,cAAM;MACR;AAGA,UAAI,iBAAiB,OAAO;AAC1B,cAAM,IAAI,aAAa,MAAM,SAAS,KAAK;MAC7C;AAEA,YAAM,IAAI,aAAa,uBAAuB;IAChD,UAAA;AACE,UAAI,WAAW;AACb,qBAAa,SAAS;MACxB;IACF;EACF;AACF,GA1LO;;;AK7GP,IAAM,gBAAgB,KAAK,KAAK;AAQzB,SAAS,YACd,MACA,MACQ;AACR,SAAO,GAAG,QAAQ,KAAK,YAAY;AACrC;AALgB;AAYhB,eAAsB,UACpB,IACA,MACA,MACgC;AAChC,QAAM,MAAM,YAAY,MAAM,IAAI;AAClC,SAAO,GAAG,IAAI,KAAK,MAAM;AAC3B;AAPsB;AAkBtB,eAAsB,SACpB,IACA,MACA,MACA,MACA,OACe;AACf,QAAM,MAAM,YAAY,MAAM,IAAI;AAClC,QAAM,QAAwB;AAAA,IAC5B;AAAA,IACA,WAAU,oBAAI,KAAK,GAAE,YAAY;AAAA,IACjC;AAAA,EACF;AAGA,QAAM,UAAU,QAAQ,CAAC,IAAI,EAAE,eAAe,cAAc;AAC5D,QAAM,GAAG,IAAI,KAAK,KAAK,UAAU,KAAK,GAAG,OAAO;AAClD;AAjBsB;AAwBtB,eAAsB,YACpB,IACA,MACA,MACe;AACf,QAAM,MAAM,YAAY,MAAM,IAAI;AAClC,QAAM,GAAG,OAAO,GAAG;AACrB;AAPsB;AActB,eAAsB,SACpB,IACA,MACA,MACkB;AAClB,QAAM,MAAM,YAAY,MAAM,IAAI;AAClC,QAAM,WAAW,MAAM,GAAG,gBAAgB,GAAG;AAC7C,SAAO,SAAS,UAAU;AAC5B;AARsB;;;AC5EtB,IAAM,kBAAkB;AAMxB,eAAsB,eAAe,KAAoC;AACvE,QAAM,KAAK,IAAI,aAAa,WAAW,eAAe;AACtD,QAAM,OAAO,IAAI,aAAa,IAAI,EAAE;AACpC,QAAM,WAAW,MAAM,KAAK,MAAM,IAAI,QAAQ,iBAAiB,CAAC;AAChE,SAAO,SAAS,KAAK;AACvB;AALsB;AAWtB,eAAsB,mBAAmB,KAAoC;AAC3E,QAAM,KAAK,IAAI,aAAa,WAAW,eAAe;AACtD,QAAM,OAAO,IAAI,aAAa,IAAI,EAAE;AACpC,QAAM,WAAW,MAAM,KAAK,MAAM,IAAI,QAAQ,kBAAkB,CAAC;AACjE,SAAO,SAAS,KAAK;AACvB;AALsB;AAUf,SAAS,oBAAoB,WAAsC;AACxE,QAAM,aAAa,KAAK;AAAA,KACrB,IAAI,KAAK,UAAU,QAAQ,EAAE,QAAQ,IAAI,KAAK,IAAI,KAAK;AAAA,EAC1D;AAEA,SAAO,SAAS;AAAA,IACd;AAAA,MACE,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,MACX;AAAA,MACA,WAAW;AAAA,QACT,WAAW;AAAA,QACX,OAAO,UAAU;AAAA,QACjB,UAAU,UAAU;AAAA,MACtB;AAAA,IACF;AAAA,IACA;AAAA,MACE,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,eAAe,OAAO,UAAU;AAAA,QAChC,qBAAqB,OAAO,UAAU,KAAK;AAAA,QAC3C,yBAAyB;AAAA,QACzB,qBAAqB,UAAU;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AACF;AA5BgB;AAiCT,SAAS,cACd,OACA,WACU;AACV,MAAI,iBAAiB,qBAAqB;AACxC,UAAM,SAAS,MAAM,SAAS,oBAAoB,MAAM;AACxD,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QACX;AAAA,QACA,WAAW;AAAA,UACT,WAAW,UAAU;AAAA,UACrB,OAAO,UAAU;AAAA,UACjB,UAAU,UAAU;AAAA,QACtB;AAAA,MACF;AAAA,MACA,EAAE,OAAO;AAAA,IACX;AAAA,EACF;AAEA,QAAM;AACR;AAxBgB;AA8BT,SAAS,aAAa,MAA+B;AAC1D,MAAI,CAAC,QAAQ,KAAK,SAAS,KAAK;AAC9B,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QACX;AAAA,MACF;AAAA,MACA,EAAE,QAAQ,IAAI;AAAA,IAChB;AAAA,EACF;AACA,SAAO;AACT;AAdgB;;;ACtEhB,eAAsB,aACpB,SACA,KACA,KACmB;AACnB,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAM,OAAO,mBAAmB,IAAI,SAAS,QAAQ,YAAY,EAAE,CAAC;AAGpE,QAAM,UAAU,aAAa,IAAI;AACjC,MAAI;AAAS,WAAO;AAGpB,QAAM,SAAS,MAAM,UAAU,IAAI,OAAO,UAAU,IAAI;AACxD,MAAI,QAAQ;AACV,UAAMA,aAAY,MAAM,mBAAmB,GAAG;AAC9C,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,MAAM,OAAO;AAAA,QACb,QAAQ;AAAA,QACR,WAAW;AAAA,UACT,WAAWA,WAAU;AAAA,UACrB,OAAOA,WAAU;AAAA,UACjB,UAAUA,WAAU;AAAA,QACtB;AAAA,MACF;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,WAAW,MAAM;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AAGA,QAAM,YAAY,MAAM,eAAe,GAAG;AAC1C,MAAI,CAAC,UAAU,SAAS;AACtB,WAAO,oBAAoB,SAAS;AAAA,EACtC;AAGA,MAAI;AACF,UAAM,KAAK,IAAI,eAAe;AAAA,MAC5B,eAAe,IAAI;AAAA,IACrB,CAAC;AAED,UAAM,SAAS,MAAM,GAAG,OAAO,IAAI;AAGnC,QAAI,UAAU,SAAS,IAAI,OAAO,UAAU,MAAM,QAAQ,OAAO,KAAK,CAAC;AAEvE,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,WAAW;AAAA,UACT,WAAW,UAAU;AAAA,UACrB,OAAO,UAAU;AAAA,UACjB,UAAU,UAAU;AAAA,QACtB;AAAA,MACF;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,WAAW,OAAO;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,SAAS,OAAP;AACA,WAAO,cAAc,OAAO,SAAS;AAAA,EACvC;AACF;AAtEsB;;;ACPtB,eAAsB,eACpB,SACA,KACA,KACmB;AACnB,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAM,OAAO,mBAAmB,IAAI,SAAS,QAAQ,cAAc,EAAE,CAAC;AAGtE,QAAM,UAAU,aAAa,IAAI;AACjC,MAAI;AAAS,WAAO;AAGpB,QAAM,SAAS,MAAM,UAAU,IAAI,OAAO,YAAY,IAAI;AAC1D,MAAI,QAAQ;AACV,UAAMC,aAAY,MAAM,mBAAmB,GAAG;AAC9C,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,MAAM,OAAO;AAAA,QACb,QAAQ;AAAA,QACR,WAAW;AAAA,UACT,WAAWA,WAAU;AAAA,UACrB,OAAOA,WAAU;AAAA,UACjB,UAAUA,WAAU;AAAA,QACtB;AAAA,MACF;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,WAAW,MAAM;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AAGA,QAAM,YAAY,MAAM,eAAe,GAAG;AAC1C,MAAI,CAAC,UAAU,SAAS;AACtB,WAAO,oBAAoB,SAAS;AAAA,EACtC;AAGA,MAAI;AACF,UAAM,KAAK,IAAI,eAAe;AAAA,MAC5B,cAAc,IAAI;AAAA,IACpB,CAAC;AAED,UAAM,SAAS,MAAM,GAAG,SAAS,IAAI;AAGrC,QAAI,UAAU,SAAS,IAAI,OAAO,YAAY,MAAM,QAAQ,OAAO,KAAK,CAAC;AAEzE,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,MAAM;AAAA,QACN,QAAQ;AAAA,QACR,WAAW;AAAA,UACT,WAAW,UAAU;AAAA,UACrB,OAAO,UAAU;AAAA,UACjB,UAAU,UAAU;AAAA,QACtB;AAAA,MACF;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,WAAW,OAAO;AAAA,MAC/B;AAAA,IACF;AAAA,EACF,SAAS,OAAP;AACA,WAAO,cAAc,OAAO,SAAS;AAAA,EACvC;AACF;AAtEsB;;;ACFtB,eAAsB,kBACpB,SACA,KACmB;AACnB,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAE/B,QAAM,QAAQ,IAAI,SAAS,MAAM,oCAAoC;AAErE,MAAI,CAAC,OAAO;AACV,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QACX;AAAA,MACF;AAAA,MACA,EAAE,QAAQ,IAAI;AAAA,IAChB;AAAA,EACF;AAEA,QAAM,OAAO,MAAM,CAAC;AACpB,QAAM,OAAO,mBAAmB,MAAM,CAAC,CAAC;AAGxC,MAAI,CAAC,QAAQ,KAAK,SAAS,KAAK;AAC9B,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,QACX;AAAA,MACF;AAAA,MACA,EAAE,QAAQ,IAAI;AAAA,IAChB;AAAA,EACF;AAGA,QAAM,SAAS,MAAM,SAAS,IAAI,OAAO,MAAM,IAAI;AAEnD,MAAI,CAAC,QAAQ;AACX,WAAO,SAAS;AAAA,MACd;AAAA,QACE,SAAS;AAAA,QACT,OAAO;AAAA,UACL,MAAM;AAAA,UACN,SAAS,uBAAuB,QAAQ;AAAA,QAC1C;AAAA,MACF;AAAA,MACA,EAAE,QAAQ,IAAI;AAAA,IAChB;AAAA,EACF;AAGA,QAAM,YAAY,IAAI,OAAO,MAAM,IAAI;AAEvC,SAAO,SAAS;AAAA,IACd;AAAA,MACE,SAAS;AAAA,MACT,MAAM;AAAA,QACJ,SAAS;AAAA,QACT;AAAA,QACA;AAAA,QACA,KAAK,YAAY,MAAM,IAAI;AAAA,MAC7B;AAAA,IACF;AAAA,IACA,EAAE,QAAQ,IAAI;AAAA,EAChB;AACF;AArEsB;;;ACPtB,IAAMC,mBAAkB;AAYxB,eAAsB,cACpB,SACA,KACA,KACmB;AACnB,QAAM,SAAS,QAAQ,QAAQ,IAAI,QAAQ;AAG3C,MAAI,QAAQ,WAAW,WAAW;AAChC,WAAO,gBAAgB,SAAS,GAAG;AAAA,EACrC;AAEA,QAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAC/B,QAAM,OAAO,IAAI;AAEjB,MAAI;AAEF,QAAI,SAAS,WAAW;AACtB,aAAO,SAAS,aAAa,GAAG,KAAK,MAAM;AAAA,IAC7C;AAGA,QAAI,SAAS,sBAAsB;AACjC,UAAI,CAAC,iBAAiB,SAAS,GAAG,GAAG;AACnC,eAAO,SAAS,qBAAqB,GAAG,KAAK,MAAM;AAAA,MACrD;AACA,aAAO,SAAS,MAAM,sBAAsB,GAAG,GAAG,KAAK,MAAM;AAAA,IAC/D;AAGA,QAAI,KAAK,WAAW,UAAU,GAAG;AAC/B,UAAI,CAAC,iBAAiB,SAAS,GAAG,GAAG;AACnC,eAAO,SAAS,qBAAqB,GAAG,KAAK,MAAM;AAAA,MACrD;AACA,aAAO,SAAS,MAAM,aAAa,SAAS,KAAK,GAAG,GAAG,KAAK,MAAM;AAAA,IACpE;AAGA,QAAI,KAAK,WAAW,YAAY,GAAG;AACjC,UAAI,CAAC,iBAAiB,SAAS,GAAG,GAAG;AACnC,eAAO,SAAS,qBAAqB,GAAG,KAAK,MAAM;AAAA,MACrD;AACA,aAAO,SAAS,MAAM,eAAe,SAAS,KAAK,GAAG,GAAG,KAAK,MAAM;AAAA,IACtE;AAGA,QAAI,KAAK,WAAW,SAAS,KAAK,QAAQ,WAAW,UAAU;AAC7D,UAAI,CAAC,kBAAkB,SAAS,GAAG,GAAG;AACpC,eAAO,SAAS,kBAAkB,GAAG,KAAK,MAAM;AAAA,MAClD;AACA,aAAO,SAAS,MAAM,kBAAkB,SAAS,GAAG,GAAG,KAAK,MAAM;AAAA,IACpE;AAGA,WAAO,SAAS,iBAAiB,GAAG,KAAK,MAAM;AAAA,EACjD,SAAS,OAAP;AACA,YAAQ,MAAM,oBAAoB,KAAK;AACvC,WAAO,SAAS,sBAAsB,GAAG,KAAK,MAAM;AAAA,EACtD;AACF;AA3DsB;AAgEtB,SAAS,eAAyB;AAChC,SAAO,SAAS,KAAK;AAAA,IACnB,QAAQ;AAAA,IACR,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,EACpC,CAAC;AACH;AALS;AAUT,eAAe,sBAAsB,KAA6B;AAChE,QAAM,KAAK,IAAI,aAAa,WAAWA,gBAAe;AACtD,QAAM,OAAO,IAAI,aAAa,IAAI,EAAE;AACpC,QAAM,WAAW,MAAM,KAAK,MAAM,IAAI,QAAQ,kBAAkB,CAAC;AACjE,QAAM,SAA0B,MAAM,SAAS,KAAK;AAEpD,SAAO,SAAS,KAAK;AAAA,IACnB,SAAS;AAAA,IACT,MAAM;AAAA,EACR,CAAC;AACH;AAVe;AAef,SAAS,uBAAiC;AACxC,SAAO,SAAS;AAAA,IACd;AAAA,MACE,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,MACX;AAAA,IACF;AAAA,IACA,EAAE,QAAQ,IAAI;AAAA,EAChB;AACF;AAXS;AAgBT,SAAS,oBAA8B;AACrC,SAAO,SAAS;AAAA,IACd;AAAA,MACE,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,MACX;AAAA,IACF;AAAA,IACA,EAAE,QAAQ,IAAI;AAAA,EAChB;AACF;AAXS;AAgBT,SAAS,mBAA6B;AACpC,SAAO,SAAS;AAAA,IACd;AAAA,MACE,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,MACX;AAAA,IACF;AAAA,IACA,EAAE,QAAQ,IAAI;AAAA,EAChB;AACF;AAXS;AAgBT,SAAS,wBAAkC;AACzC,SAAO,SAAS;AAAA,IACd;AAAA,MACE,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN,SAAS;AAAA,MACX;AAAA,IACF;AAAA,IACA,EAAE,QAAQ,IAAI;AAAA,EAChB;AACF;AAXS;;;AC7IF,IAAM,cAAN,MAA2C;AAAA,EACxC;AAAA,EACA;AAAA,EAER,YAAY,OAA2B,KAAU;AAC/C,SAAK,QAAQ;AACb,SAAK,QAAQ,SAAS,IAAI,uBAAuB,QAAQ,EAAE;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,MAAM,SAAqC;AAC/C,UAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;AAE/B,QAAI,IAAI,aAAa,UAAU;AAC7B,aAAO,KAAK,kBAAkB;AAAA,IAChC;AAEA,QAAI,IAAI,aAAa,WAAW;AAC9B,aAAO,KAAK,UAAU;AAAA,IACxB;AAEA,WAAO,IAAI,SAAS,aAAa,EAAE,QAAQ,IAAI,CAAC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,oBAAuC;AACnD,UAAM,QAAQ,KAAK,YAAY;AAC/B,UAAM,SAAS,MAAM,KAAK,MAAM,QAAQ,IAGrC,SAAS;AAEZ,QAAI,QAAQ;AACZ,QAAI,UAAU,OAAO,SAAS,OAAO;AACnC,cAAQ,OAAO;AAAA,IACjB;AAGA,QAAI,SAAS,KAAK,OAAO;AACvB,aAAO,SAAS,KAAK;AAAA,QACnB,SAAS;AAAA,QACT,WAAW;AAAA,QACX,OAAO,KAAK;AAAA,QACZ,UAAU,KAAK,mBAAmB;AAAA,MACpC,CAA2B;AAAA,IAC7B;AAGA,UAAM,KAAK,MAAM,QAAQ,IAAI,WAAW;AAAA,MACtC,MAAM;AAAA,MACN,OAAO,QAAQ;AAAA,IACjB,CAAC;AAED,WAAO,SAAS,KAAK;AAAA,MACnB,SAAS;AAAA,MACT,WAAW,KAAK,QAAQ,QAAQ;AAAA,MAChC,OAAO,KAAK;AAAA,MACZ,UAAU,KAAK,mBAAmB;AAAA,IACpC,CAA2B;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,YAA+B;AAC3C,UAAM,QAAQ,KAAK,YAAY;AAC/B,UAAM,SAAS,MAAM,KAAK,MAAM,QAAQ,IAGrC,SAAS;AAEZ,QAAI,QAAQ;AACZ,QAAI,UAAU,OAAO,SAAS,OAAO;AACnC,cAAQ,OAAO;AAAA,IACjB;AAEA,WAAO,SAAS,KAAK;AAAA,MACnB,SAAS;AAAA;AAAA,MACT,WAAW,KAAK,QAAQ;AAAA,MACxB,OAAO,KAAK;AAAA,MACZ,UAAU,KAAK,mBAAmB;AAAA,IACpC,CAA2B;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAsB;AAC5B,YAAO,oBAAI,KAAK,GAAE,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAA6B;AACnC,UAAM,WAAW,oBAAI,KAAK;AAC1B,aAAS,WAAW,SAAS,WAAW,IAAI,CAAC;AAC7C,aAAS,YAAY,GAAG,GAAG,GAAG,CAAC;AAC/B,WAAO,SAAS,YAAY;AAAA,EAC9B;AACF;AAhHa;;;ACOb,IAAO,cAAQ;AAAA,EACb,MAAM,MACJ,SACA,KACA,KACmB;AACnB,WAAO,cAAc,SAAS,KAAK,GAAG;AAAA,EACxC;AACF;;;AC5BA,IAAM,YAAwB,8BAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,UAAE;AACD,QAAI;AACH,UAAI,QAAQ,SAAS,QAAQ,CAAC,QAAQ,UAAU;AAC/C,cAAM,SAAS,QAAQ,KAAK,UAAU;AACtC,eAAO,EAAE,MAAM,OAAO,KAAK,GAAG,MAAM;AAAA,QAAC;AAAA,MACtC;AAAA,IACD,SAAS,GAAP;AACD,cAAQ,MAAM,4CAA4C,CAAC;AAAA,IAC5D;AAAA,EACD;AACD,GAb8B;AAe9B,IAAO,6CAAQ;;;ACRf,SAAS,YAAY,GAAmB;AACvC,SAAO;AAAA,IACN,MAAM,GAAG;AAAA,IACT,SAAS,GAAG,WAAW,OAAO,CAAC;AAAA,IAC/B,OAAO,GAAG;AAAA,IACV,OAAO,GAAG,UAAU,SAAY,SAAY,YAAY,EAAE,KAAK;AAAA,EAChE;AACD;AAPS;AAUT,IAAM,YAAwB,8BAAO,SAAS,KAAK,MAAM,kBAAkB;AAC1E,MAAI;AACH,WAAO,MAAM,cAAc,KAAK,SAAS,GAAG;AAAA,EAC7C,SAAS,GAAP;AACD,UAAM,QAAQ,YAAY,CAAC;AAC3B,WAAO,SAAS,KAAK,OAAO;AAAA,MAC3B,QAAQ;AAAA,MACR,SAAS,EAAE,+BAA+B,OAAO;AAAA,IAClD,CAAC;AAAA,EACF;AACD,GAV8B;AAY9B,IAAO,2CAAQ;;;ACzBJ,IAAM,mCAAmC;AAAA,EAE9B;AAAA,EAAyB;AAC3C;AACA,IAAO,sCAAQ;;;ACcnB,IAAM,wBAAsC,CAAC;AAKtC,SAAS,uBAAuB,MAAqC;AAC3E,wBAAsB,KAAK,GAAG,KAAK,KAAK,CAAC;AAC1C;AAFgB;AAShB,SAAS,uBACR,SACA,KACA,KACA,UACA,iBACsB;AACtB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI;AACxB,QAAM,gBAAmC;AAAA,IACxC;AAAA,IACA,KAAK,YAAY,QAAQ;AACxB,aAAO,uBAAuB,YAAY,QAAQ,KAAK,UAAU,IAAI;AAAA,IACtE;AAAA,EACD;AACA,SAAO,KAAK,SAAS,KAAK,KAAK,aAAa;AAC7C;AAfS;AAiBF,SAAS,kBACf,SACA,KACA,KACA,UACA,iBACsB;AACtB,SAAO,uBAAuB,SAAS,KAAK,KAAK,UAAU;AAAA,IAC1D,GAAG;AAAA,IACH;AAAA,EACD,CAAC;AACF;AAXgB;;;AC3ChB,IAAM,iCAAN,MAAoE;AAAA,EAGnE,YACU,eACA,MACT,SACC;AAHQ;AACA;AAGT,SAAK,WAAW;AAAA,EACjB;AAAA,EARS;AAAA,EAUT,UAAU;AACT,QAAI,EAAE,gBAAgB,iCAAiC;AACtD,YAAM,IAAI,UAAU,oBAAoB;AAAA,IACzC;AAEA,SAAK,SAAS;AAAA,EACf;AACD;AAlBM;AAoBN,SAAS,oBAAoB,QAA0C;AAEtE,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAEA,QAAM,kBAA+C,gCACpD,SACA,KACA,KACC;AACD,QAAI,OAAO,UAAU,QAAW;AAC/B,YAAM,IAAI,MAAM,6CAA6C;AAAA,IAC9D;AACA,WAAO,OAAO,MAAM,SAAS,KAAK,GAAG;AAAA,EACtC,GATqD;AAWrD,SAAO;AAAA,IACN,GAAG;AAAA,IACH,MAAM,SAAS,KAAK,KAAK;AACxB,YAAM,aAAyB,gCAAU,MAAM,MAAM;AACpD,YAAI,SAAS,eAAe,OAAO,cAAc,QAAW;AAC3D,gBAAM,aAAa,IAAI;AAAA,YACtB,KAAK,IAAI;AAAA,YACT,KAAK,QAAQ;AAAA,YACb,MAAM;AAAA,YAAC;AAAA,UACR;AACA,iBAAO,OAAO,UAAU,YAAY,KAAK,GAAG;AAAA,QAC7C;AAAA,MACD,GAT+B;AAU/B,aAAO,kBAAkB,SAAS,KAAK,KAAK,YAAY,eAAe;AAAA,IACxE;AAAA,EACD;AACD;AAxCS;AA0CT,SAAS,qBACR,OAC8B;AAE9B,MACC,qCAAqC,UACrC,iCAAiC,WAAW,GAC3C;AACD,WAAO;AAAA,EACR;AAEA,aAAW,cAAc,kCAAkC;AAC1D,wBAAoB,UAAU;AAAA,EAC/B;AAGA,SAAO,cAAc,MAAM;AAAA,IAC1B,mBAAyE,CACxE,SACA,KACA,QACI;AACJ,WAAK,MAAM;AACX,WAAK,MAAM;AACX,UAAI,MAAM,UAAU,QAAW;AAC9B,cAAM,IAAI,MAAM,sDAAsD;AAAA,MACvE;AACA,aAAO,MAAM,MAAM,OAAO;AAAA,IAC3B;AAAA,IAEA,cAA0B,CAAC,MAAM,SAAS;AACzC,UAAI,SAAS,eAAe,MAAM,cAAc,QAAW;AAC1D,cAAM,aAAa,IAAI;AAAA,UACtB,KAAK,IAAI;AAAA,UACT,KAAK,QAAQ;AAAA,UACb,MAAM;AAAA,UAAC;AAAA,QACR;AACA,eAAO,MAAM,UAAU,UAAU;AAAA,MAClC;AAAA,IACD;AAAA,IAEA,MAAM,SAAwD;AAC7D,aAAO;AAAA,QACN;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,MACN;AAAA,IACD;AAAA,EACD;AACD;AAnDS;AAqDT,IAAI;AACJ,IAAI,OAAO,wCAAU,UAAU;AAC9B,kBAAgB,oBAAoB,mCAAK;AAC1C,WAAW,OAAO,wCAAU,YAAY;AACvC,kBAAgB,qBAAqB,mCAAK;AAC3C;AACA,IAAO,kCAAQ;",
  "names": ["rateLimit", "rateLimit", "RATE_LIMITER_ID"]
}
